---
layout: post
category: "knowledge"
title: "c++11新特性"
tags: [c++11, ]
---

目录

<!-- TOC -->

- [0. 简介](#0-简介)
- [1. 核心语言的运行期表现强化](#1-核心语言的运行期表现强化)
    - [1.1 右值引用和move语义](#11-右值引用和move语义)
    - [1.2 constexpr – 泛化的常量表示式](#12-constexpr--泛化的常量表示式)
    - [1.3 对POD定义的修正](#13-对pod定义的修正)
- [2. 核心语言构造期表现的加强](#2-核心语言构造期表现的加强)
    - [2.1 外部模板](#21-外部模板)
- [3. 核心语言使用性的加强](#3-核心语言使用性的加强)
    - [3.1 初始化列表](#31-初始化列表)
    - [3.2 统一的初始化](#32-统一的初始化)
    - [3.3 类型推导](#33-类型推导)
    - [3.4 基于范围的for循环](#34-基于范围的for循环)
    - [3.5 Lambda函数与表示式](#35-lambda函数与表示式)
    - [3.6 回返类型后置的函数声明](#36-回返类型后置的函数声明)
    - [3.7 对象构造的改良](#37-对象构造的改良)
    - [3.8 显式虚函数重载](#38-显式虚函数重载)
    - [3.9 空指针](#39-空指针)
    - [3.10 强类型枚举](#310-强类型枚举)
    - [3.11 角括号](#311-角括号)
    - [3.12 显式类型转换子](#312-显式类型转换子)
    - [3.13 模板的别名](#313-模板的别名)
    - [3.14 无限制的unions](#314-无限制的unions)
- [4. 核心语言能力的提升](#4-核心语言能力的提升)
    - [4.1 可变参数模板](#41-可变参数模板)
    - [4.2 新的字符串字面值](#42-新的字符串字面值)
    - [4.3 用户定义字面量](#43-用户定义字面量)
    - [4.4 多任务内存模型](#44-多任务内存模型)
    - [4.5 thread-local的存储期限](#45-thread-local的存储期限)
    - [4.6 使用或禁用对象的默认函数](#46-使用或禁用对象的默认函数)
    - [4.7 long long int类型](#47-long-long-int类型)
    - [4.8 静态assertion](#48-静态assertion)
    - [4.9 允许sizeof运算符作用在类别的数据成员上，无须明确的对象](#49-允许sizeof运算符作用在类别的数据成员上无须明确的对象)
    - [4.10 垃圾回收机制](#410-垃圾回收机制)
- [5. C++标准程序库的变更](#5-c标准程序库的变更)
    - [5.1 标准库组件上的升级](#51-标准库组件上的升级)
    - [5.2 线程支持](#52-线程支持)
    - [5.3 多元组类型](#53-多元组类型)
    - [5.4 散列表](#54-散列表)
    - [5.5 正则表达式](#55-正则表达式)
    - [5.6 通用智能指针](#56-通用智能指针)
    - [5.7 可扩展的随机数功能](#57-可扩展的随机数功能)
    - [5.8 包装引用](#58-包装引用)
    - [5.9 多态函数对象包装器](#59-多态函数对象包装器)
    - [5.10 用于元编程的类型属性](#510-用于元编程的类型属性)
    - [5.11 用于计算函数对象回返类型的统一方法](#511-用于计算函数对象回返类型的统一方法)
    - [5.12 iota 函数](#512-iota-函数)
- [X. 示例](#x-示例)
    - [shuffle](#shuffle)
    - [atomic](#atomic)

<!-- /TOC -->

参考：
[C++11新特性](https://www.cnblogs.com/pzhfei/archive/2013/03/02/CPP_new_feature.html)

[英文维基百科: c++11](https://en.wikipedia.org/wiki/C++11)
[中文维基百科：c++11](https://zh.wikipedia.org/wiki/C%2B%2B11)

## 0. 简介

C++11,之前被称作C++0x，即ISO/IEC 14882:2011，是目前的C++编程语言的正式标准。它取代第二版标准ISO/IEC 14882:2003(第一版ISO/IEC 14882:1998发布于1998年，第二版于2003年发布，分别通称C++98以及C++03，两者差异很小)。新的标准包含了几个核心语言增加的新特性，而且扩展C++标准程序库，并入了大部分的C++ Technical Report 1程序库(数学的特殊函数除外)。最新的消息被公布在 ISO C++ 委员会网站(英文)。
ISO／IEC JTC1/SC22/WG21 C++ 标准委员会计划在2010年8月之前完成对最终委员会草案的投票，以及于2011年3月召开的标准会议完成国际标准的最终草案。然而，WG21预期ISO将要花费六个月到一年的时间才能正式发布新的C++标准。为了能够如期完成，委员会决定致力于直至2006年为止的提案，忽略新的提案。最终,于2011年8月12日公布，并于2011年9月出版。2012年2月28日的国际标准草案(N3376)是最接近于现行标准的草案，差异仅有编辑上的修正。
像C++这样的编程语言，通过一种演化的过程来发展其定义。这个过程不可避免地将引发与现有代码的兼容问题。不过根据Bjarne Stroustrup(C++的创始人,标准委员会的一员)表示，新的标准将几乎100%兼容现有标准。

## 1. 核心语言的运行期表现强化

提升某些性能表现，例如内存或是速度上的表现。

### 1.1 右值引用和move语义

### 1.2 constexpr – 泛化的常量表示式

### 1.3 对POD定义的修正

## 2. 核心语言构造期表现的加强

### 2.1 外部模板

## 3. 核心语言使用性的加强

### 3.1 初始化列表
### 3.2 统一的初始化
### 3.3 类型推导
### 3.4 基于范围的for循环
### 3.5 Lambda函数与表示式
### 3.6 回返类型后置的函数声明
### 3.7 对象构造的改良
### 3.8 显式虚函数重载
### 3.9 空指针
### 3.10 强类型枚举
### 3.11 角括号
### 3.12 显式类型转换子
### 3.13 模板的别名
### 3.14 无限制的unions

## 4. 核心语言能力的提升

### 4.1 可变参数模板

在 C++11 之前, 不论是类模板或是函数模板，都只能按其被声明时所指定的样子，**接受一组数目固定的模板参数**。C++11 加入新的表示法，允许**任意个数，任意类型的模板参数**，不必在定义时将参数的个数固定。

先写：

```c++
template<typename... Values> class tuple;
```

然后，模板类 tuple 的对象，能接受不限个数的 typename 作为它的模板形参(如下面的```int/vector<int>/map<std::string, std::vector<int>>>```)。

```c++
class tuple<int, std::vector<int>, std::map<std::string, std::vector<int>>> someInstanceName;
```

实参的个数也可以是0,所以```class tuple<> someInstanceName```这样的定义也是可以的。

若不希望产生实参个数为 0 的变长参数模板，则可以采用以下的定义：

```c++
template<typename First, typename... Rest> class tuple;
```

举个例子：

```c++
template <typename OutputType, typename...Args>
class baseClass {
    virtual int32_t process(OutputType *, const Args* ...) = 0;
};
```

实现一个子类如下，这样是没有问题的

```c++
class derivedClass: public baseClass<int, string, bool> {
    int32_t process(int* a, const string* b, const bool* c) override {
        return 0;
    }
};

int main()
{
    derivedClass xxx;
    return 0;
}
```

但如果把其中的一个const xxx*的指针去掉，如：

```c++
class derivedClass: public baseClass<int, string, bool> { 
    int32_t process(int* a, const string b, const bool* c) override {
        return 0;
    }
};
int main()
{
    derivedClass xxx;
    return 0;
}
```

因为我们写了override标识，所以直接就报错了，一方面是这个函数并非是我们想要重载的基类的纯虚函数，另一方面没有重载纯虚函数的子类是无法被实例化的~

```
./tmplt.h:18:13: error: 'int32_t derivedClass::process(int*, std::string, const bool*)' marked override, but does not override
     int32_t process(int* a, const string b, const bool* c) override {
             ^
./main.cpp: In function 'int main()':
./main.cpp:31:18: error: cannot declare variable 'xxx' to be of abstract type 'derivedClass'
     derivedClass xxx;
                  ^
In file included from ./main.cpp:5:0:
./tmplt.h:17:7: note:   because the following virtual functions are pure within 'derivedClass':
 class derivedClass: baseClass<int, string, bool> {
       ^
./tmplt.h:14:21: note:  int32_t baseClass<OutputType, Args>::process(OutputType*, const Args* ...) [with OutputType = int; Args = {std::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool}; int32_t = int]
     virtual int32_t process(OutputType *, const Args* ...) = 0;
```

而如果我们去掉override标识，报错就只剩没有实现纯虚函数的了，因为process函数被当做子类自己的新函数：

```
./main.cpp: In function 'int main()':
./main.cpp:31:18: error: cannot declare variable 'xxx' to be of abstract type 'derivedClass'
     derivedClass xxx;
                  ^
In file included from ./main.cpp:5:0:
./tmplt.h:15:7: note:   because the following virtual functions are pure within 'derivedClass':
 class derivedClass: baseClass<int, string, bool> {
       ^
./tmplt.h:12:21: note:  int32_t baseClass<OutputType, Args>::process(OutputType*, const Args* ...) [with OutputType = int; Args = {std::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool}; int32_t = int]
     virtual int32_t process(OutputType *, const Args* ...) = 0;
```

另外，在这个子类里，这个process函数可以自由地声明成private/protected/public，都行~

### 4.2 新的字符串字面值
### 4.3 用户定义字面量
### 4.4 多任务内存模型
### 4.5 thread-local的存储期限
### 4.6 使用或禁用对象的默认函数
### 4.7 long long int类型
### 4.8 静态assertion
### 4.9 允许sizeof运算符作用在类别的数据成员上，无须明确的对象
### 4.10 垃圾回收机制

## 5. C++标准程序库的变更

### 5.1 标准库组件上的升级
### 5.2 线程支持
### 5.3 多元组类型
### 5.4 散列表
### 5.5 正则表达式
### 5.6 通用智能指针
### 5.7 可扩展的随机数功能
### 5.8 包装引用
### 5.9 多态函数对象包装器
### 5.10 用于元编程的类型属性
### 5.11 用于计算函数对象回返类型的统一方法
### 5.12 iota 函数


## X. 示例

### shuffle 

```C++
#include <random>

bool score_cmp(const RidTmpInfoPtr& first, const RidTmpInfoPtr& second) {
    return first->score > second->score;
}

bool func() {
    auto result_end = result.begin();
    std::advance(result_end, video_rec_buf.tmp_result_len);

    auto generator = std::mt19937(std::random_device()());
    std::exponential_distribution<float> distribution;
    for (auto& item: result) {
        item->score = -distribution(generator) * exp(-item->res_score);
    }
    std::sort(result.begin(), result_end, score_cmp);
}
```

### atomic

[http://zh.cppreference.com/w/cpp/atomic/atomic](http://zh.cppreference.com/w/cpp/atomic/atomic)